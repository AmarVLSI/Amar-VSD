//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro
`include "./include/sp_verilog.vh" //_\SV
   //m4_include_lib(⌈https://raw.githubusercontent.com/stevehoover/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv⌉)
   // Included URL: "https://raw.githubusercontent.com/arunkpv/vsd-hdp/main/code/riscv/verilog/include/risc-v_shell_lib.tlv"// Included URL: "https://raw.githubusercontent.com/arunkpv/vsd-hdp/main/code/riscv/verilog/include/risc-v_defs.tlv"

   // Module interface, either for Makerchip, or not.
   
      // Makerchip module interface.
      module riscv_core(input wire clk, input wire reset, output reg [9:0] out );

// ---------- Generated Code Inlined Here (before 1st \TLV) ----------
// Generated by SandPiper(TM) 1.14-2022/10/10-beta-Pro from Redwood EDA, LLC.
// (Installed here: /usr/local/mono/sandpiper/distro.)
// Redwood EDA, LLC does not claim intellectual property rights to this file and provides no warranty regarding its correctness or quality.


// For silencing unused signal messages.
`define BOGUS_USE(ignore)


`include "./include/sandpiper_gen.vh"


genvar dmem, imem, xreg;


//
// Signals declared top-level.
//

// For |cpu$br_tgt_pc.
(* keep *) wire [31:0] CPU_br_tgt_pc_a2;
reg  [31:0] CPU_br_tgt_pc_a3;

// For |cpu$dec_bits.
wire [10:0] CPU_dec_bits_a1;

// For |cpu$dmem_addr.
(* keep *) wire [3:0] CPU_dmem_addr_a4;

// For |cpu$dmem_rd_data.
(* keep *) wire [31:0] CPU_dmem_rd_data_a4;
reg  [31:0] CPU_dmem_rd_data_a5;

// For |cpu$dmem_rd_en.
(* keep *) wire CPU_dmem_rd_en_a4;

// For |cpu$dmem_wr_data.
(* keep *) wire [31:0] CPU_dmem_wr_data_a4;

// For |cpu$dmem_wr_en.
(* keep *) wire CPU_dmem_wr_en_a4;

// For |cpu$funct3.
wire [2:0] CPU_funct3_a1;

// For |cpu$funct3_valid.
wire CPU_funct3_valid_a1;

// For |cpu$funct7.
wire [6:0] CPU_funct7_a1;

// For |cpu$funct7_valid.
wire CPU_funct7_valid_a1;

// For |cpu$imem_rd_addr.
(* keep *) wire [4-1:0] CPU_imem_rd_addr_a0;
reg  [4-1:0] CPU_imem_rd_addr_a1;

// For |cpu$imem_rd_data.
(* keep *) wire [31:0] CPU_imem_rd_data_a1;

// For |cpu$imem_rd_en.
(* keep *) wire CPU_imem_rd_en_a0;
reg  CPU_imem_rd_en_a1;

// For |cpu$imm.
(* keep *) wire [31:0] CPU_imm_a1;
reg  [31:0] CPU_imm_a2,
            CPU_imm_a3;

// For |cpu$inc_pc.
wire [31:0] CPU_inc_pc_a1;
reg  [31:0] CPU_inc_pc_a2,
            CPU_inc_pc_a3;

// For |cpu$instr.
(* keep *) wire [31:0] CPU_instr_a1;

// For |cpu$is_add.
wire CPU_is_add_a1;
reg  CPU_is_add_a2,
     CPU_is_add_a3;

// For |cpu$is_addi.
wire CPU_is_addi_a1;
reg  CPU_is_addi_a2,
     CPU_is_addi_a3;

// For |cpu$is_and.
wire CPU_is_and_a1;
reg  CPU_is_and_a2,
     CPU_is_and_a3;

// For |cpu$is_andi.
wire CPU_is_andi_a1;
reg  CPU_is_andi_a2,
     CPU_is_andi_a3;

// For |cpu$is_auipc.
wire CPU_is_auipc_a1;
reg  CPU_is_auipc_a2,
     CPU_is_auipc_a3;

// For |cpu$is_b_instr.
(* keep *) wire CPU_is_b_instr_a1;

// For |cpu$is_beq.
wire CPU_is_beq_a1;
reg  CPU_is_beq_a2,
     CPU_is_beq_a3;

// For |cpu$is_bge.
wire CPU_is_bge_a1;
reg  CPU_is_bge_a2,
     CPU_is_bge_a3;

// For |cpu$is_bgeu.
wire CPU_is_bgeu_a1;
reg  CPU_is_bgeu_a2,
     CPU_is_bgeu_a3;

// For |cpu$is_blt.
wire CPU_is_blt_a1;
reg  CPU_is_blt_a2,
     CPU_is_blt_a3;

// For |cpu$is_bltu.
wire CPU_is_bltu_a1;
reg  CPU_is_bltu_a2,
     CPU_is_bltu_a3;

// For |cpu$is_bne.
wire CPU_is_bne_a1;
reg  CPU_is_bne_a2,
     CPU_is_bne_a3;

// For |cpu$is_i_instr.
(* keep *) wire CPU_is_i_instr_a1;

// For |cpu$is_j_instr.
(* keep *) wire CPU_is_j_instr_a1;

// For |cpu$is_jal.
wire CPU_is_jal_a1;
reg  CPU_is_jal_a2,
     CPU_is_jal_a3;

// For |cpu$is_jalr.
wire CPU_is_jalr_a1;
reg  CPU_is_jalr_a2,
     CPU_is_jalr_a3;

// For |cpu$is_jump.
(* keep *) wire CPU_is_jump_a1;
reg  CPU_is_jump_a2,
     CPU_is_jump_a3;

// For |cpu$is_load.
(* keep *) wire CPU_is_load_a1;
reg  CPU_is_load_a2,
     CPU_is_load_a3;

// For |cpu$is_lui.
wire CPU_is_lui_a1;
reg  CPU_is_lui_a2,
     CPU_is_lui_a3;

// For |cpu$is_or.
wire CPU_is_or_a1;
reg  CPU_is_or_a2,
     CPU_is_or_a3;

// For |cpu$is_ori.
wire CPU_is_ori_a1;
reg  CPU_is_ori_a2,
     CPU_is_ori_a3;

// For |cpu$is_r_instr.
(* keep *) wire CPU_is_r_instr_a1;

// For |cpu$is_s_instr.
(* keep *) wire CPU_is_s_instr_a1;
reg  CPU_is_s_instr_a2,
     CPU_is_s_instr_a3,
     CPU_is_s_instr_a4;

// For |cpu$is_sb.
wire CPU_is_sb_a1;

// For |cpu$is_sh.
wire CPU_is_sh_a1;

// For |cpu$is_sll.
wire CPU_is_sll_a1;
reg  CPU_is_sll_a2,
     CPU_is_sll_a3;

// For |cpu$is_slli.
wire CPU_is_slli_a1;
reg  CPU_is_slli_a2,
     CPU_is_slli_a3;

// For |cpu$is_slt.
wire CPU_is_slt_a1;
reg  CPU_is_slt_a2,
     CPU_is_slt_a3;

// For |cpu$is_slti.
wire CPU_is_slti_a1;
reg  CPU_is_slti_a2,
     CPU_is_slti_a3;

// For |cpu$is_sltiu.
wire CPU_is_sltiu_a1;
reg  CPU_is_sltiu_a2,
     CPU_is_sltiu_a3;

// For |cpu$is_sltu.
wire CPU_is_sltu_a1;
reg  CPU_is_sltu_a2,
     CPU_is_sltu_a3;

// For |cpu$is_sra.
wire CPU_is_sra_a1;
reg  CPU_is_sra_a2,
     CPU_is_sra_a3;

// For |cpu$is_srai.
wire CPU_is_srai_a1;
reg  CPU_is_srai_a2,
     CPU_is_srai_a3;

// For |cpu$is_srl.
wire CPU_is_srl_a1;
reg  CPU_is_srl_a2,
     CPU_is_srl_a3;

// For |cpu$is_srli.
wire CPU_is_srli_a1;
reg  CPU_is_srli_a2,
     CPU_is_srli_a3;

// For |cpu$is_sub.
wire CPU_is_sub_a1;
reg  CPU_is_sub_a2,
     CPU_is_sub_a3;

// For |cpu$is_sw.
wire CPU_is_sw_a1;

// For |cpu$is_u_instr.
(* keep *) wire CPU_is_u_instr_a1;

// For |cpu$is_xor.
wire CPU_is_xor_a1;
reg  CPU_is_xor_a2,
     CPU_is_xor_a3;

// For |cpu$is_xori.
wire CPU_is_xori_a1;
reg  CPU_is_xori_a2,
     CPU_is_xori_a3;

// For |cpu$jalr_tgt_pc.
wire [31:0] CPU_jalr_tgt_pc_a3;

// For |cpu$ld_data.
(* keep *) wire [31:0] CPU_ld_data_a5;

// For |cpu$opcode.
(* keep *) wire [6:0] CPU_opcode_a1;

// For |cpu$pc.
(* keep *) wire [31:0] CPU_pc_a0;
reg  [31:0] CPU_pc_a1,
            CPU_pc_a2,
            CPU_pc_a3;

// For |cpu$rd.
wire [4:0] CPU_rd_a1;
reg  [4:0] CPU_rd_a2,
           CPU_rd_a3,
           CPU_rd_a4,
           CPU_rd_a5;

// For |cpu$rd_valid.
wire CPU_rd_valid_a1;
reg  CPU_rd_valid_a2,
     CPU_rd_valid_a3;

// For |cpu$reset.
wire CPU_reset_a0;
reg  CPU_reset_a1,
     CPU_reset_a2,
     CPU_reset_a3,
     CPU_reset_a4;

// For |cpu$result.
(* keep *) wire [31:0] CPU_result_a3;
reg  [5:2] CPU_result_a4;

// For |cpu$rf_rd_data1.
(* keep *) wire [31:0] CPU_rf_rd_data1_a2;

// For |cpu$rf_rd_data2.
(* keep *) wire [31:0] CPU_rf_rd_data2_a2;

// For |cpu$rf_rd_en1.
(* keep *) wire CPU_rf_rd_en1_a2;

// For |cpu$rf_rd_en2.
(* keep *) wire CPU_rf_rd_en2_a2;

// For |cpu$rf_rd_index1.
(* keep *) wire [4:0] CPU_rf_rd_index1_a2;

// For |cpu$rf_rd_index2.
(* keep *) wire [4:0] CPU_rf_rd_index2_a2;

// For |cpu$rf_wr_data.
(* keep *) wire [31:0] CPU_rf_wr_data_a3;

// For |cpu$rf_wr_en.
(* keep *) wire CPU_rf_wr_en_a3;

// For |cpu$rf_wr_index.
(* keep *) wire [4:0] CPU_rf_wr_index_a3;

// For |cpu$rs1.
(* keep *) wire [4:0] CPU_rs1_a1;
reg  [4:0] CPU_rs1_a2;

// For |cpu$rs1_valid.
(* keep *) wire CPU_rs1_valid_a1;
reg  CPU_rs1_valid_a2;

// For |cpu$rs2.
(* keep *) wire [4:0] CPU_rs2_a1;
reg  [4:0] CPU_rs2_a2;

// For |cpu$rs2_valid.
(* keep *) wire CPU_rs2_valid_a1;
reg  CPU_rs2_valid_a2;

// For |cpu$sltiu_rslt.
wire [31:0] CPU_sltiu_rslt_a3;

// For |cpu$sltu_rslt.
wire [31:0] CPU_sltu_rslt_a3;

// For |cpu$src1_value.
(* keep *) wire [31:0] CPU_src1_value_a2;
reg  [31:0] CPU_src1_value_a3;

// For |cpu$src2_value.
(* keep *) wire [31:0] CPU_src2_value_a2;
reg  [31:0] CPU_src2_value_a3,
            CPU_src2_value_a4;

// For |cpu$taken_br.
wire CPU_taken_br_a3;

// For |cpu$valid.
(* keep *) wire CPU_valid_a3;
reg  CPU_valid_a4;

// For |cpu$valid_jump.
(* keep *) wire CPU_valid_jump_a3;
reg  CPU_valid_jump_a4,
     CPU_valid_jump_a5;

// For |cpu$valid_load.
(* keep *) wire CPU_valid_load_a3;
reg  CPU_valid_load_a4,
     CPU_valid_load_a5;

// For |cpu$valid_taken_br.
(* keep *) wire CPU_valid_taken_br_a3;
reg  CPU_valid_taken_br_a4,
     CPU_valid_taken_br_a5;

// For |cpu/dmem$value.
(* keep *) wire [31:0] CPU_Dmem_value_a4 [15:0];
reg  [31:0] CPU_Dmem_value_a5 [15:0];

// For |cpu/imem$instr.
(* keep *) wire [31:0] CPU_Imem_instr_a1 [11:0];

// For |cpu/xreg$value.
wire [31:0] CPU_Xreg_value_a3 [31:0];
reg  [31:0] CPU_Xreg_value_a4 [31:0],
            CPU_Xreg_value_a5 [31:0];




   //
   // Scope: |cpu
   //

      // Staging of $br_tgt_pc.
      always @(posedge clk) CPU_br_tgt_pc_a3[31:0] <= CPU_br_tgt_pc_a2[31:0];

      // Staging of $dmem_rd_data.
      always @(posedge clk) CPU_dmem_rd_data_a5[31:0] <= CPU_dmem_rd_data_a4[31:0];

      // Staging of $imem_rd_addr.
      always @(posedge clk) CPU_imem_rd_addr_a1[4-1:0] <= CPU_imem_rd_addr_a0[4-1:0];

      // Staging of $imem_rd_en.
      always @(posedge clk) CPU_imem_rd_en_a1 <= CPU_imem_rd_en_a0;

      // Staging of $imm.
      always @(posedge clk) CPU_imm_a2[31:0] <= CPU_imm_a1[31:0];
      always @(posedge clk) CPU_imm_a3[31:0] <= CPU_imm_a2[31:0];

      // Staging of $inc_pc.
      always @(posedge clk) CPU_inc_pc_a2[31:0] <= CPU_inc_pc_a1[31:0];
      always @(posedge clk) CPU_inc_pc_a3[31:0] <= CPU_inc_pc_a2[31:0];

      // Staging of $is_add.
      always @(posedge clk) CPU_is_add_a2 <= CPU_is_add_a1;
      always @(posedge clk) CPU_is_add_a3 <= CPU_is_add_a2;

      // Staging of $is_addi.
      always @(posedge clk) CPU_is_addi_a2 <= CPU_is_addi_a1;
      always @(posedge clk) CPU_is_addi_a3 <= CPU_is_addi_a2;

      // Staging of $is_and.
      always @(posedge clk) CPU_is_and_a2 <= CPU_is_and_a1;
      always @(posedge clk) CPU_is_and_a3 <= CPU_is_and_a2;

      // Staging of $is_andi.
      always @(posedge clk) CPU_is_andi_a2 <= CPU_is_andi_a1;
      always @(posedge clk) CPU_is_andi_a3 <= CPU_is_andi_a2;

      // Staging of $is_auipc.
      always @(posedge clk) CPU_is_auipc_a2 <= CPU_is_auipc_a1;
      always @(posedge clk) CPU_is_auipc_a3 <= CPU_is_auipc_a2;

      // Staging of $is_beq.
      always @(posedge clk) CPU_is_beq_a2 <= CPU_is_beq_a1;
      always @(posedge clk) CPU_is_beq_a3 <= CPU_is_beq_a2;

      // Staging of $is_bge.
      always @(posedge clk) CPU_is_bge_a2 <= CPU_is_bge_a1;
      always @(posedge clk) CPU_is_bge_a3 <= CPU_is_bge_a2;

      // Staging of $is_bgeu.
      always @(posedge clk) CPU_is_bgeu_a2 <= CPU_is_bgeu_a1;
      always @(posedge clk) CPU_is_bgeu_a3 <= CPU_is_bgeu_a2;

      // Staging of $is_blt.
      always @(posedge clk) CPU_is_blt_a2 <= CPU_is_blt_a1;
      always @(posedge clk) CPU_is_blt_a3 <= CPU_is_blt_a2;

      // Staging of $is_bltu.
      always @(posedge clk) CPU_is_bltu_a2 <= CPU_is_bltu_a1;
      always @(posedge clk) CPU_is_bltu_a3 <= CPU_is_bltu_a2;

      // Staging of $is_bne.
      always @(posedge clk) CPU_is_bne_a2 <= CPU_is_bne_a1;
      always @(posedge clk) CPU_is_bne_a3 <= CPU_is_bne_a2;

      // Staging of $is_jal.
      always @(posedge clk) CPU_is_jal_a2 <= CPU_is_jal_a1;
      always @(posedge clk) CPU_is_jal_a3 <= CPU_is_jal_a2;

      // Staging of $is_jalr.
      always @(posedge clk) CPU_is_jalr_a2 <= CPU_is_jalr_a1;
      always @(posedge clk) CPU_is_jalr_a3 <= CPU_is_jalr_a2;

      // Staging of $is_jump.
      always @(posedge clk) CPU_is_jump_a2 <= CPU_is_jump_a1;
      always @(posedge clk) CPU_is_jump_a3 <= CPU_is_jump_a2;

      // Staging of $is_load.
      always @(posedge clk) CPU_is_load_a2 <= CPU_is_load_a1;
      always @(posedge clk) CPU_is_load_a3 <= CPU_is_load_a2;

      // Staging of $is_lui.
      always @(posedge clk) CPU_is_lui_a2 <= CPU_is_lui_a1;
      always @(posedge clk) CPU_is_lui_a3 <= CPU_is_lui_a2;

      // Staging of $is_or.
      always @(posedge clk) CPU_is_or_a2 <= CPU_is_or_a1;
      always @(posedge clk) CPU_is_or_a3 <= CPU_is_or_a2;

      // Staging of $is_ori.
      always @(posedge clk) CPU_is_ori_a2 <= CPU_is_ori_a1;
      always @(posedge clk) CPU_is_ori_a3 <= CPU_is_ori_a2;

      // Staging of $is_s_instr.
      always @(posedge clk) CPU_is_s_instr_a2 <= CPU_is_s_instr_a1;
      always @(posedge clk) CPU_is_s_instr_a3 <= CPU_is_s_instr_a2;
      always @(posedge clk) CPU_is_s_instr_a4 <= CPU_is_s_instr_a3;

      // Staging of $is_sll.
      always @(posedge clk) CPU_is_sll_a2 <= CPU_is_sll_a1;
      always @(posedge clk) CPU_is_sll_a3 <= CPU_is_sll_a2;

      // Staging of $is_slli.
      always @(posedge clk) CPU_is_slli_a2 <= CPU_is_slli_a1;
      always @(posedge clk) CPU_is_slli_a3 <= CPU_is_slli_a2;

      // Staging of $is_slt.
      always @(posedge clk) CPU_is_slt_a2 <= CPU_is_slt_a1;
      always @(posedge clk) CPU_is_slt_a3 <= CPU_is_slt_a2;

      // Staging of $is_slti.
      always @(posedge clk) CPU_is_slti_a2 <= CPU_is_slti_a1;
      always @(posedge clk) CPU_is_slti_a3 <= CPU_is_slti_a2;

      // Staging of $is_sltiu.
      always @(posedge clk) CPU_is_sltiu_a2 <= CPU_is_sltiu_a1;
      always @(posedge clk) CPU_is_sltiu_a3 <= CPU_is_sltiu_a2;

      // Staging of $is_sltu.
      always @(posedge clk) CPU_is_sltu_a2 <= CPU_is_sltu_a1;
      always @(posedge clk) CPU_is_sltu_a3 <= CPU_is_sltu_a2;

      // Staging of $is_sra.
      always @(posedge clk) CPU_is_sra_a2 <= CPU_is_sra_a1;
      always @(posedge clk) CPU_is_sra_a3 <= CPU_is_sra_a2;

      // Staging of $is_srai.
      always @(posedge clk) CPU_is_srai_a2 <= CPU_is_srai_a1;
      always @(posedge clk) CPU_is_srai_a3 <= CPU_is_srai_a2;

      // Staging of $is_srl.
      always @(posedge clk) CPU_is_srl_a2 <= CPU_is_srl_a1;
      always @(posedge clk) CPU_is_srl_a3 <= CPU_is_srl_a2;

      // Staging of $is_srli.
      always @(posedge clk) CPU_is_srli_a2 <= CPU_is_srli_a1;
      always @(posedge clk) CPU_is_srli_a3 <= CPU_is_srli_a2;

      // Staging of $is_sub.
      always @(posedge clk) CPU_is_sub_a2 <= CPU_is_sub_a1;
      always @(posedge clk) CPU_is_sub_a3 <= CPU_is_sub_a2;

      // Staging of $is_xor.
      always @(posedge clk) CPU_is_xor_a2 <= CPU_is_xor_a1;
      always @(posedge clk) CPU_is_xor_a3 <= CPU_is_xor_a2;

      // Staging of $is_xori.
      always @(posedge clk) CPU_is_xori_a2 <= CPU_is_xori_a1;
      always @(posedge clk) CPU_is_xori_a3 <= CPU_is_xori_a2;

      // Staging of $pc.
      always @(posedge clk) CPU_pc_a1[31:0] <= CPU_pc_a0[31:0];
      always @(posedge clk) CPU_pc_a2[31:0] <= CPU_pc_a1[31:0];
      always @(posedge clk) CPU_pc_a3[31:0] <= CPU_pc_a2[31:0];

      // Staging of $rd.
      always @(posedge clk) CPU_rd_a2[4:0] <= CPU_rd_a1[4:0];
      always @(posedge clk) CPU_rd_a3[4:0] <= CPU_rd_a2[4:0];
      always @(posedge clk) CPU_rd_a4[4:0] <= CPU_rd_a3[4:0];
      always @(posedge clk) CPU_rd_a5[4:0] <= CPU_rd_a4[4:0];

      // Staging of $rd_valid.
      always @(posedge clk) CPU_rd_valid_a2 <= CPU_rd_valid_a1;
      always @(posedge clk) CPU_rd_valid_a3 <= CPU_rd_valid_a2;

      // Staging of $reset.
      always @(posedge clk) CPU_reset_a1 <= CPU_reset_a0;
      always @(posedge clk) CPU_reset_a2 <= CPU_reset_a1;
      always @(posedge clk) CPU_reset_a3 <= CPU_reset_a2;
      always @(posedge clk) CPU_reset_a4 <= CPU_reset_a3;

      // Staging of $result.
      always @(posedge clk) CPU_result_a4[5:2] <= CPU_result_a3[5:2];

      // Staging of $rs1.
      always @(posedge clk) CPU_rs1_a2[4:0] <= CPU_rs1_a1[4:0];

      // Staging of $rs1_valid.
      always @(posedge clk) CPU_rs1_valid_a2 <= CPU_rs1_valid_a1;

      // Staging of $rs2.
      always @(posedge clk) CPU_rs2_a2[4:0] <= CPU_rs2_a1[4:0];

      // Staging of $rs2_valid.
      always @(posedge clk) CPU_rs2_valid_a2 <= CPU_rs2_valid_a1;

      // Staging of $src1_value.
      always @(posedge clk) CPU_src1_value_a3[31:0] <= CPU_src1_value_a2[31:0];

      // Staging of $src2_value.
      always @(posedge clk) CPU_src2_value_a3[31:0] <= CPU_src2_value_a2[31:0];
      always @(posedge clk) CPU_src2_value_a4[31:0] <= CPU_src2_value_a3[31:0];

      // Staging of $valid.
      always @(posedge clk) CPU_valid_a4 <= CPU_valid_a3;

      // Staging of $valid_jump.
      always @(posedge clk) CPU_valid_jump_a4 <= CPU_valid_jump_a3;
      always @(posedge clk) CPU_valid_jump_a5 <= CPU_valid_jump_a4;

      // Staging of $valid_load.
      always @(posedge clk) CPU_valid_load_a4 <= CPU_valid_load_a3;
      always @(posedge clk) CPU_valid_load_a5 <= CPU_valid_load_a4;

      // Staging of $valid_taken_br.
      always @(posedge clk) CPU_valid_taken_br_a4 <= CPU_valid_taken_br_a3;
      always @(posedge clk) CPU_valid_taken_br_a5 <= CPU_valid_taken_br_a4;


      //
      // Scope: /dmem[15:0]
      //
      generate for (dmem = 0; dmem <= 15; dmem=dmem+1) begin : L1gen_CPU_Dmem
         // Staging of $value.
         always @(posedge clk) CPU_Dmem_value_a5[dmem][31:0] <= CPU_Dmem_value_a4[dmem][31:0];

      end endgenerate

      //
      // Scope: /xreg[31:0]
      //
      generate for (xreg = 0; xreg <= 31; xreg=xreg+1) begin : L1gen_CPU_Xreg
         // Staging of $value.
         always @(posedge clk) CPU_Xreg_value_a4[xreg][31:0] <= CPU_Xreg_value_a3[xreg][31:0];
         always @(posedge clk) CPU_Xreg_value_a5[xreg][31:0] <= CPU_Xreg_value_a4[xreg][31:0];

      end endgenerate





//
// Debug Signals
//

//generate
//
//   if (1) begin : DEBUG_SIGS
//
//
//      //
//      // Scope: |cpu
//      //
//      if (1) begin : \|cpu 
//         wire [31:0] \/@2$br_tgt_pc ;
//         assign \/@2$br_tgt_pc = CPU_br_tgt_pc_a2;
//         wire [10:0] \/@1$dec_bits ;
//         assign \/@1$dec_bits = CPU_dec_bits_a1;
//         wire [3:0] \/@4$dmem_addr ;
//         assign \/@4$dmem_addr = CPU_dmem_addr_a4;
//         wire [31:0] \/?$dmem_rd_en@4$dmem_rd_data ;
//         assign \/?$dmem_rd_en@4$dmem_rd_data = CPU_dmem_rd_data_a4;
//         wire  \/@4$dmem_rd_en ;
//         assign \/@4$dmem_rd_en = CPU_dmem_rd_en_a4;
//         wire [31:0] \/@4$dmem_wr_data ;
//         assign \/@4$dmem_wr_data = CPU_dmem_wr_data_a4;
//         wire  \/@4$dmem_wr_en ;
//         assign \/@4$dmem_wr_en = CPU_dmem_wr_en_a4;
//         wire [2:0] \/?$funct3_valid@1$funct3 ;
//         assign \/?$funct3_valid@1$funct3 = CPU_funct3_a1;
//         wire  \/@1$funct3_valid ;
//         assign \/@1$funct3_valid = CPU_funct3_valid_a1;
//         wire [6:0] \/?$funct7_valid@1$funct7 ;
//         assign \/?$funct7_valid@1$funct7 = CPU_funct7_a1;
//         wire  \/@1$funct7_valid ;
//         assign \/@1$funct7_valid = CPU_funct7_valid_a1;
//         wire [4-1:0] \/@0$imem_rd_addr ;
//         assign \/@0$imem_rd_addr = CPU_imem_rd_addr_a0;
//         wire [31:0] \/?$imem_rd_en@1$imem_rd_data ;
//         assign \/?$imem_rd_en@1$imem_rd_data = CPU_imem_rd_data_a1;
//         wire  \/@0$imem_rd_en ;
//         assign \/@0$imem_rd_en = CPU_imem_rd_en_a0;
//         wire [31:0] \/@1$imm ;
//         assign \/@1$imm = CPU_imm_a1;
//         wire [31:0] \/@1$inc_pc ;
//         assign \/@1$inc_pc = CPU_inc_pc_a1;
//         wire [31:0] \/@1$instr ;
//         assign \/@1$instr = CPU_instr_a1;
//         wire  \/@1$is_add ;
//         assign \/@1$is_add = CPU_is_add_a1;
//         wire  \/@1$is_addi ;
//         assign \/@1$is_addi = CPU_is_addi_a1;
//         wire  \/@1$is_and ;
//         assign \/@1$is_and = CPU_is_and_a1;
//         wire  \/@1$is_andi ;
//         assign \/@1$is_andi = CPU_is_andi_a1;
//         wire  \/@1$is_auipc ;
//         assign \/@1$is_auipc = CPU_is_auipc_a1;
//         wire  \/@1$is_b_instr ;
//         assign \/@1$is_b_instr = CPU_is_b_instr_a1;
//         wire  \/@1$is_beq ;
//         assign \/@1$is_beq = CPU_is_beq_a1;
//         wire  \/@1$is_bge ;
//         assign \/@1$is_bge = CPU_is_bge_a1;
//         wire  \/@1$is_bgeu ;
//         assign \/@1$is_bgeu = CPU_is_bgeu_a1;
//         wire  \/@1$is_blt ;
//         assign \/@1$is_blt = CPU_is_blt_a1;
//         wire  \/@1$is_bltu ;
//         assign \/@1$is_bltu = CPU_is_bltu_a1;
//         wire  \/@1$is_bne ;
//         assign \/@1$is_bne = CPU_is_bne_a1;
//         wire  \/@1$is_i_instr ;
//         assign \/@1$is_i_instr = CPU_is_i_instr_a1;
//         wire  \/@1$is_j_instr ;
//         assign \/@1$is_j_instr = CPU_is_j_instr_a1;
//         wire  \/@1$is_jal ;
//         assign \/@1$is_jal = CPU_is_jal_a1;
//         wire  \/@1$is_jalr ;
//         assign \/@1$is_jalr = CPU_is_jalr_a1;
//         wire  \/@1$is_jump ;
//         assign \/@1$is_jump = CPU_is_jump_a1;
//         wire  \/@1$is_load ;
//         assign \/@1$is_load = CPU_is_load_a1;
//         wire  \/@1$is_lui ;
//         assign \/@1$is_lui = CPU_is_lui_a1;
//         wire  \/@1$is_or ;
//         assign \/@1$is_or = CPU_is_or_a1;
//         wire  \/@1$is_ori ;
//         assign \/@1$is_ori = CPU_is_ori_a1;
//         wire  \/@1$is_r_instr ;
//         assign \/@1$is_r_instr = CPU_is_r_instr_a1;
//         wire  \/@1$is_s_instr ;
//         assign \/@1$is_s_instr = CPU_is_s_instr_a1;
//         wire  \/@1$is_sb ;
//         assign \/@1$is_sb = CPU_is_sb_a1;
//         wire  \/@1$is_sh ;
//         assign \/@1$is_sh = CPU_is_sh_a1;
//         wire  \/@1$is_sll ;
//         assign \/@1$is_sll = CPU_is_sll_a1;
//         wire  \/@1$is_slli ;
//         assign \/@1$is_slli = CPU_is_slli_a1;
//         wire  \/@1$is_slt ;
//         assign \/@1$is_slt = CPU_is_slt_a1;
//         wire  \/@1$is_slti ;
//         assign \/@1$is_slti = CPU_is_slti_a1;
//         wire  \/@1$is_sltiu ;
//         assign \/@1$is_sltiu = CPU_is_sltiu_a1;
//         wire  \/@1$is_sltu ;
//         assign \/@1$is_sltu = CPU_is_sltu_a1;
//         wire  \/@1$is_sra ;
//         assign \/@1$is_sra = CPU_is_sra_a1;
//         wire  \/@1$is_srai ;
//         assign \/@1$is_srai = CPU_is_srai_a1;
//         wire  \/@1$is_srl ;
//         assign \/@1$is_srl = CPU_is_srl_a1;
//         wire  \/@1$is_srli ;
//         assign \/@1$is_srli = CPU_is_srli_a1;
//         wire  \/@1$is_sub ;
//         assign \/@1$is_sub = CPU_is_sub_a1;
//         wire  \/@1$is_sw ;
//         assign \/@1$is_sw = CPU_is_sw_a1;
//         wire  \/@1$is_u_instr ;
//         assign \/@1$is_u_instr = CPU_is_u_instr_a1;
//         wire  \/@1$is_xor ;
//         assign \/@1$is_xor = CPU_is_xor_a1;
//         wire  \/@1$is_xori ;
//         assign \/@1$is_xori = CPU_is_xori_a1;
//         wire [31:0] \/@3$jalr_tgt_pc ;
//         assign \/@3$jalr_tgt_pc = CPU_jalr_tgt_pc_a3;
//         wire [31:0] \/@5$ld_data ;
//         assign \/@5$ld_data = CPU_ld_data_a5;
//         wire [6:0] \/@1$opcode ;
//         assign \/@1$opcode = CPU_opcode_a1;
//         wire [31:0] \/@0$pc ;
//         assign \/@0$pc = CPU_pc_a0;
//         wire [4:0] \/?$rd_valid@1$rd ;
//         assign \/?$rd_valid@1$rd = CPU_rd_a1;
//         wire  \/@1$rd_valid ;
//         assign \/@1$rd_valid = CPU_rd_valid_a1;
//         wire  \/@0$reset ;
//         assign \/@0$reset = CPU_reset_a0;
//         wire [31:0] \/@3$result ;
//         assign \/@3$result = CPU_result_a3;
//         wire [31:0] \/?$rf_rd_en1@2$rf_rd_data1 ;
//         assign \/?$rf_rd_en1@2$rf_rd_data1 = CPU_rf_rd_data1_a2;
//         wire [31:0] \/?$rf_rd_en2@2$rf_rd_data2 ;
//         assign \/?$rf_rd_en2@2$rf_rd_data2 = CPU_rf_rd_data2_a2;
//         wire  \/@2$rf_rd_en1 ;
//         assign \/@2$rf_rd_en1 = CPU_rf_rd_en1_a2;
//         wire  \/@2$rf_rd_en2 ;
//         assign \/@2$rf_rd_en2 = CPU_rf_rd_en2_a2;
//         wire [4:0] \/@2$rf_rd_index1 ;
//         assign \/@2$rf_rd_index1 = CPU_rf_rd_index1_a2;
//         wire [4:0] \/@2$rf_rd_index2 ;
//         assign \/@2$rf_rd_index2 = CPU_rf_rd_index2_a2;
//         wire [31:0] \/@3$rf_wr_data ;
//         assign \/@3$rf_wr_data = CPU_rf_wr_data_a3;
//         wire  \/@3$rf_wr_en ;
//         assign \/@3$rf_wr_en = CPU_rf_wr_en_a3;
//         wire [4:0] \/@3$rf_wr_index ;
//         assign \/@3$rf_wr_index = CPU_rf_wr_index_a3;
//         wire [4:0] \/?$rs1_valid@1$rs1 ;
//         assign \/?$rs1_valid@1$rs1 = CPU_rs1_a1;
//         wire  \/@1$rs1_valid ;
//         assign \/@1$rs1_valid = CPU_rs1_valid_a1;
//         wire [4:0] \/?$rs2_valid@1$rs2 ;
//         assign \/?$rs2_valid@1$rs2 = CPU_rs2_a1;
//         wire  \/@1$rs2_valid ;
//         assign \/@1$rs2_valid = CPU_rs2_valid_a1;
//         wire [31:0] \/@3$sltiu_rslt ;
//         assign \/@3$sltiu_rslt = CPU_sltiu_rslt_a3;
//         wire [31:0] \/@3$sltu_rslt ;
//         assign \/@3$sltu_rslt = CPU_sltu_rslt_a3;
//         wire [31:0] \/@2$src1_value ;
//         assign \/@2$src1_value = CPU_src1_value_a2;
//         wire [31:0] \/@2$src2_value ;
//         assign \/@2$src2_value = CPU_src2_value_a2;
//         wire  \/@3$taken_br ;
//         assign \/@3$taken_br = CPU_taken_br_a3;
//         wire  \/@3$valid ;
//         assign \/@3$valid = CPU_valid_a3;
//         wire  \/@3$valid_jump ;
//         assign \/@3$valid_jump = CPU_valid_jump_a3;
//         wire  \/@3$valid_load ;
//         assign \/@3$valid_load = CPU_valid_load_a3;
//         wire  \/@3$valid_taken_br ;
//         assign \/@3$valid_taken_br = CPU_valid_taken_br_a3;
//
//         //
//         // Scope: /dmem[15:0]
//         //
//         for (dmem = 0; dmem <= 15; dmem=dmem+1) begin : \/dmem 
//            wire [31:0] \//@4$value ;
//            assign \//@4$value = CPU_Dmem_value_a4[dmem];
//            wire  \//@4$wr ;
//            assign \//@4$wr = L1_CPU_Dmem[dmem].L1_wr_a4;
//         end
//
//         //
//         // Scope: /imem[11:0]
//         //
//         for (imem = 0; imem <= 11; imem=imem+1) begin : \/imem 
//            wire [31:0] \//@1$instr ;
//            assign \//@1$instr = CPU_Imem_instr_a1[imem];
//         end
//
//         //
//         // Scope: /xreg[31:0]
//         //
//         for (xreg = 0; xreg <= 31; xreg=xreg+1) begin : \/xreg 
//            wire [31:0] \//@3$value ;
//            assign \//@3$value = CPU_Xreg_value_a3[xreg];
//            wire  \//@3$wr ;
//            assign \//@3$wr = L1_CPU_Xreg[xreg].L1_wr_a3;
//         end
//      end
//
//
//   end
//
//endgenerate

// ---------- Generated Code Ends ----------
//_\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   // Inst #0: ADD,r10,r0,r0           // Initialize r10 to 0.
   // Inst #1: ADD,r15,r0,r0           // Initialize r15 to 0.
   // Function:
   // Inst #2: ADD,r14,r0,r0           // Initialize partial sum register r14 with 0x0
   // Inst #3: ADDI,r12,r0,1010          // Store count of 10 in register r12.
   // Inst #4: ADD,r13,r0,r0           // Initialize count register r13 with 0
   // Loop:
   // Inst #5: ADD,r14,r13,r14           // Incremental addition
   // Inst #6: ADDI,r13,r13,1             // Increment count register by 1
   // Inst #7: BLT,r13,r12,1111111111000 // If r13 is less than r12, branch to label named <loop>
                                         // 0xFFFF_FFF8 = -8 (decimal)
   // Inst #8: ADD,r10,r14,r0            // Store final result to register r10 so that it can be read by main program
   
   // Inst #9: SW,r0,r10,00100           // DMEM[1] = r10 = 45 (2d)
   // Inst #10: LW,r15,r0,00100           // r15 = DMEM[1] = 45 (2d)
   
   // Optional: Jump to itself (infinite loop)
   // Inst #11: JAL,r7,111111111111111010100 // Offset[20:0] = -44 (0x1F_FFD4)
                                          // including implicit LSB '0'
   
   // Additional instructions added to test out the RAW hazard during Load redirect
   //m4_asm(ADD,  r1, r15, r1)      // r1 = r1 + r15 = 46 (2e)
   //m4_asm(ADD,  r1,  r1, r1)      // r1 = r1 + r1  = 92 (5c)
   //m4_asm(LW,   r2,  r0, 10000)   // r2 = DMEM[4] = 4
   //m4_asm(ADD,  r3,  r2, r3)      // r3 = r2 + r3 = 4 + 3 = 7
   //m4_asm(SW,   r0,  r3, 01100)   // DMEM[3] = r3 = 7
   //m4_asm(LW,   r2,  r0, 00100)   // r2 = DMEM[1] = 45 (2d)
   //m4_asm(ADD,  r2,  r2, r2)      // r2 = r2 + r2 = 90 (5a)
   
   
   

   //_|cpu
      //_@0
         assign CPU_reset_a0 = reset;
         
         // PC logic
         // Use the previous $br_tgt_pc if the branch was taken in the previous instruction
         assign CPU_pc_a0[31:0] = CPU_reset_a1 ? 32'b0 :
                     CPU_valid_taken_br_a3 ? CPU_br_tgt_pc_a3 :
                     (CPU_valid_jump_a3 && CPU_is_jal_a3) ? CPU_br_tgt_pc_a3 :
                     (CPU_valid_jump_a3 && CPU_is_jalr_a3) ? CPU_jalr_tgt_pc_a3 :
                     CPU_valid_load_a3 ? CPU_inc_pc_a3 :
                     CPU_inc_pc_a1;
         
         // IMEM Enable, ReadAddress port connections:
         // Assuming IMEM is DWORD-addressable, align the PC with the IMEM Read address port
         // Essentially, PC[1:0] = 2'b0. Hence, we can make the connection as follows:
         assign CPU_imem_rd_en_a0 = !CPU_reset_a0;
         assign CPU_imem_rd_addr_a0[4-1:0] = CPU_pc_a0[4+1:2]; //imem_rd_addr[31:0]
         
         // Start signal pulses for 1 cycle immediately after reset deassertion
         //$start = >>1$reset && !$reset;
         
         // Valid signal is a 3-Cycle valid corresponding to the 3-stage pipeline we are 
         // implementing. Following reset deassertion, toggles as follows: 100100100...
         //$valid = $reset ? 1'b0 :
         //                  $start ? 1'b1 : >>3$valid;
      //_@1
         // Increment PC by 1 instruction length (fixed 4 bytes) every cycle
         assign CPU_inc_pc_a1[31:0] = CPU_pc_a1 + 32'd4;
         
         // INSTRUCTION FETCH
         assign CPU_instr_a1[31:0] = CPU_imem_rd_data_a1[31:0];
         
         // INSTRUCTION-TYPE DECODE:
         // $instr[1:0] = 2'b11 for RV32I Base
         // Register
         assign CPU_is_r_instr_a1 = (CPU_instr_a1[6:2] == 5'b01011) ||
                       (CPU_instr_a1[6:2] == 5'b01100) ||
                       (CPU_instr_a1[6:2] == 5'b01110) ||
                       (CPU_instr_a1[6:2] == 5'b10100);
         
         // Immediate
         assign CPU_is_i_instr_a1 = (CPU_instr_a1[6:2] == 5'b00000) ||
                       (CPU_instr_a1[6:2] == 5'b00001) ||
                       (CPU_instr_a1[6:2] == 5'b00100) ||
                       (CPU_instr_a1[6:2] == 5'b00110) ||
                       (CPU_instr_a1[6:2] == 5'b11001);
         
         // Store
         assign CPU_is_s_instr_a1 = (CPU_instr_a1[6:2] == 5'b01000) ||
                       (CPU_instr_a1[6:2] == 5'b01001);
         
         // Branch
         assign CPU_is_b_instr_a1 = (CPU_instr_a1[6:2] == 5'b11000);
         
         // Upper Immediate
         assign CPU_is_u_instr_a1 = (CPU_instr_a1[6:2] == 5'b00101) ||
                       (CPU_instr_a1[6:2] == 5'b01101);
         
         // Jump
         assign CPU_is_j_instr_a1 = (CPU_instr_a1[6:2] == 5'b11011);
         
         // IMMEDIATE VALUE DECODE
         assign CPU_imm_a1[31:0] = CPU_is_i_instr_a1 ? {{21{CPU_instr_a1[31]}}, CPU_instr_a1[30:20]} :
                      CPU_is_s_instr_a1 ? {{21{CPU_instr_a1[31]}}, CPU_instr_a1[30:25], CPU_instr_a1[11:7]} :
                      CPU_is_b_instr_a1 ? {{20{CPU_instr_a1[31]}}, CPU_instr_a1[7], CPU_instr_a1[30:25], CPU_instr_a1[11:8], 1'b0} :
                      CPU_is_u_instr_a1 ? {CPU_instr_a1[31:12], 12'b0} :
                      CPU_is_j_instr_a1 ? {{12{CPU_instr_a1[31]}}, CPU_instr_a1[19:12], CPU_instr_a1[20], CPU_instr_a1[30:21], 1'b0} :
                      32'b0;
         
         // INSTRUCTION DECODING
         assign CPU_opcode_a1[6:0] = CPU_instr_a1[6:0];
         
         assign CPU_rd_valid_a1     = CPU_is_r_instr_a1 | CPU_is_i_instr_a1 | CPU_is_u_instr_a1 | CPU_is_j_instr_a1;
         assign CPU_funct3_valid_a1 = CPU_is_r_instr_a1 | CPU_is_i_instr_a1 | CPU_is_s_instr_a1 | CPU_is_b_instr_a1;
         assign CPU_rs1_valid_a1    = CPU_is_r_instr_a1 | CPU_is_i_instr_a1 | CPU_is_s_instr_a1 | CPU_is_b_instr_a1;
         assign CPU_rs2_valid_a1    = CPU_is_r_instr_a1 | CPU_is_s_instr_a1 | CPU_is_b_instr_a1;
         assign CPU_funct7_valid_a1 = CPU_is_r_instr_a1;
         
         //_?$rd_valid
            assign CPU_rd_a1[4:0]     = CPU_instr_a1[11:7];
         //_?$funct3_valid
            assign CPU_funct3_a1[2:0] = CPU_instr_a1[14:12];
         //_?$rs1_valid
            assign CPU_rs1_a1[4:0]    = CPU_instr_a1[19:15];
         //_?$rs2_valid
            assign CPU_rs2_a1[4:0]    = CPU_instr_a1[24:20];
         //_?$funct7_valid
            assign CPU_funct7_a1[6:0] = CPU_instr_a1[31:25];
         
         // Decode the individual instructions
         assign CPU_dec_bits_a1[10:0] = {CPU_funct7_a1[5], CPU_funct3_a1[2:0], CPU_opcode_a1[6:0]};
         
         assign CPU_is_lui_a1   = (CPU_dec_bits_a1[6:0] == 7'b0110111);
         assign CPU_is_auipc_a1 = (CPU_dec_bits_a1[6:0] == 7'b0010111);
         assign CPU_is_jal_a1   = (CPU_dec_bits_a1[6:0] == 7'b1101111);
         assign CPU_is_jalr_a1  = (CPU_dec_bits_a1[9:0] == 10'b000_1100111);
         
         assign CPU_is_beq_a1  = (CPU_dec_bits_a1[9:0] == 10'b000_1100011);
         assign CPU_is_bne_a1  = (CPU_dec_bits_a1[9:0] == 10'b001_1100011);
         assign CPU_is_blt_a1  = (CPU_dec_bits_a1[9:0] == 10'b100_1100011);
         assign CPU_is_bge_a1  = (CPU_dec_bits_a1[9:0] == 10'b101_1100011);
         assign CPU_is_bltu_a1 = (CPU_dec_bits_a1[9:0] == 10'b110_1100011);
         assign CPU_is_bgeu_a1 = (CPU_dec_bits_a1[9:0] == 10'b111_1100011);
         
         assign CPU_is_load_a1 = (CPU_opcode_a1 == 7'b0000011);    // All load instructions are treated the same
         
         assign CPU_is_sb_a1 = (CPU_dec_bits_a1[9:0] == 10'b000_0100011);
         assign CPU_is_sh_a1 = (CPU_dec_bits_a1[9:0] == 10'b001_0100011);
         assign CPU_is_sw_a1 = (CPU_dec_bits_a1[9:0] == 10'b010_0100011);
         
         assign CPU_is_addi_a1  = (CPU_dec_bits_a1[9:0]  == 10'b000_0010011);
         assign CPU_is_slti_a1  = (CPU_dec_bits_a1[9:0]  == 10'b010_0010011);
         assign CPU_is_sltiu_a1 = (CPU_dec_bits_a1[9:0]  == 10'b011_0010011);
         assign CPU_is_xori_a1  = (CPU_dec_bits_a1[9:0]  == 10'b100_0010011);
         assign CPU_is_ori_a1   = (CPU_dec_bits_a1[9:0]  == 10'b110_0010011);
         assign CPU_is_andi_a1  = (CPU_dec_bits_a1[9:0]  == 10'b111_0010011);
         assign CPU_is_slli_a1  = (CPU_dec_bits_a1[10:0] == 11'b0_001_0010011);
         assign CPU_is_srli_a1  = (CPU_dec_bits_a1[10:0] == 11'b0_101_0010011);
         assign CPU_is_srai_a1  = (CPU_dec_bits_a1[10:0] == 11'b1_101_0010011);
         assign CPU_is_add_a1   = (CPU_dec_bits_a1[10:0] == 11'b0_000_0110011);
         assign CPU_is_sub_a1   = (CPU_dec_bits_a1[10:0] == 11'b1_000_0110011);
         assign CPU_is_sll_a1   = (CPU_dec_bits_a1[10:0] == 11'b0_001_0110011);
         assign CPU_is_slt_a1   = (CPU_dec_bits_a1[10:0] == 11'b0_010_0110011);
         assign CPU_is_sltu_a1  = (CPU_dec_bits_a1[10:0] == 11'b0_011_0110011);
         assign CPU_is_xor_a1   = (CPU_dec_bits_a1[10:0] == 11'b0_100_0110011);
         assign CPU_is_srl_a1   = (CPU_dec_bits_a1[10:0] == 11'b0_101_0110011);
         assign CPU_is_sra_a1   = (CPU_dec_bits_a1[10:0] == 11'b1_101_0110011);
         assign CPU_is_or_a1    = (CPU_dec_bits_a1[10:0] == 11'b0_110_0110011);
         assign CPU_is_and_a1   = (CPU_dec_bits_a1[10:0] == 11'b0_111_0110011);
         
         assign CPU_is_jump_a1 = (CPU_is_jal_a1 || CPU_is_jalr_a1);
         
         //`BOGUS_USE(CPU_is_beq_a1 CPU_is_bne_a1 CPU_is_blt_a1 CPU_is_bge_a1 CPU_is_bltu_a1 CPU_is_bgeu_a1 CPU_is_load_a1 CPU_is_sb_a1 CPU_is_sh_a1 CPU_is_sw_a1 CPU_is_addi_a1);
         //`BOGUS_USE(CPU_is_slti_a1 CPU_is_sltiu_a1 CPU_is_xori_a1 CPU_is_ori_a1 CPU_is_andi_a1 CPU_is_slli_a1 CPU_is_srli_a1 CPU_is_srai_a1 CPU_is_add_a1 CPU_is_sub_a1);
         //`BOGUS_USE(CPU_is_sll_a1 CPU_is_slt_a1 CPU_is_sltu_a1 CPU_is_xor_a1 CPU_is_srl_a1 CPU_is_sra_a1 CPU_is_or_a1 CPU_is_and_a1);
         
      //_@2
         // Target PC for a branch instruction
         assign CPU_br_tgt_pc_a2[31:0] = CPU_pc_a2 + CPU_imm_a2;
         
         // REGISTER FILE READ
         //$rf_reset = $reset;
         assign CPU_rf_rd_en1_a2 = CPU_rs1_valid_a2;
         assign CPU_rf_rd_index1_a2[4:0] = CPU_rs1_a2;
         assign CPU_rf_rd_en2_a2 = CPU_rs2_valid_a2;
         assign CPU_rf_rd_index2_a2[4:0] = CPU_rs2_a2;
         
         // Handling Read-After-Write Hazard
         assign CPU_src1_value_a2[31:0] = (CPU_rf_wr_index_a3 == CPU_rf_rd_index1_a2) && CPU_rf_wr_en_a3
                             ? CPU_rf_wr_data_a3 : CPU_rf_rd_data1_a2;
         
         assign CPU_src2_value_a2[31:0] = (CPU_rf_wr_index_a3 == CPU_rf_rd_index2_a2) && CPU_rf_wr_en_a3
                             ? CPU_rf_wr_data_a3 : CPU_rf_rd_data2_a2;
         
      //_@3
         // ALU
         // Intermediate result signals for SLT, SLTI instructions
         assign CPU_sltu_rslt_a3[31:0]   = (CPU_src1_value_a3 < CPU_src2_value_a3);
         assign CPU_sltiu_rslt_a3[31:0]  = (CPU_src1_value_a3 < CPU_imm_a3);
         
         assign CPU_result_a3[31:0] = CPU_is_lui_a3   ? CPU_imm_a3[31:0] :
                         CPU_is_auipc_a3 ? (CPU_pc_a3 + CPU_imm_a3) :
                         CPU_is_jal_a3   ? (CPU_pc_a3 + 32'd4) :
                         CPU_is_jalr_a3  ? (CPU_pc_a3 + 32'd4) :
                         (CPU_is_load_a3 || CPU_is_s_instr_a3) ? (CPU_src1_value_a3 + CPU_imm_a3) :
                         CPU_is_sll_a3   ? (CPU_src1_value_a3 << CPU_src2_value_a3[4:0]) :
                         CPU_is_slli_a3  ? (CPU_src1_value_a3 << CPU_imm_a3[5:0]) :
                         CPU_is_srl_a3   ? (CPU_src1_value_a3 >> CPU_src2_value_a3[4:0]) :
                         CPU_is_srli_a3  ? (CPU_src1_value_a3 >> CPU_imm_a3[5:0]) :
                         CPU_is_sra_a3   ? ({{32{CPU_src1_value_a3[31]}}, CPU_src1_value_a3} >> CPU_src2_value_a3[4:0]) :
                         CPU_is_srai_a3  ? ({{32{CPU_src1_value_a3[31]}}, CPU_src1_value_a3} >> CPU_imm_a3[4:0]) :
                         CPU_is_add_a3   ? (CPU_src1_value_a3 + CPU_src2_value_a3) :
                         CPU_is_addi_a3  ? (CPU_src1_value_a3 + CPU_imm_a3) :
                         CPU_is_sub_a3   ? (CPU_src1_value_a3 - CPU_src2_value_a3) :
                         CPU_is_xor_a3   ? (CPU_src1_value_a3 ^ CPU_src2_value_a3) :
                         CPU_is_xori_a3  ? (CPU_src1_value_a3 ^ CPU_imm_a3) :
                         CPU_is_and_a3   ? (CPU_src1_value_a3 & CPU_src2_value_a3) :
                         CPU_is_andi_a3  ? (CPU_src1_value_a3 & CPU_imm_a3) :
                         CPU_is_or_a3    ? (CPU_src1_value_a3 | CPU_src2_value_a3) :
                         CPU_is_ori_a3   ? (CPU_src1_value_a3 | CPU_imm_a3) :
                         CPU_is_slt_a3   ? (CPU_src1_value_a3[31] == CPU_src2_value_a3[31]) ? CPU_sltu_rslt_a3 : {31'b0, CPU_src1_value_a3[31]} :
                         CPU_is_slti_a3  ? (CPU_src1_value_a3[31] == CPU_imm_a3[31]) ? CPU_sltiu_rslt_a3 : {31'b0, CPU_src1_value_a3[31]} :
                         CPU_is_sltu_a3  ? (CPU_src1_value_a3 < CPU_src2_value_a3) :
                         CPU_is_sltiu_a3 ? (CPU_src1_value_a3 < CPU_imm_a3) :
                         32'bx;
         
         // BRANCH INSTRNS.
         assign CPU_taken_br_a3 = CPU_is_beq_a3  ? (CPU_src1_value_a3 == CPU_src2_value_a3) :
                     CPU_is_bne_a3  ? (CPU_src1_value_a3 != CPU_src2_value_a3) :
                     CPU_is_bltu_a3 ? (CPU_src1_value_a3 <  CPU_src2_value_a3) :
                     CPU_is_bgeu_a3 ? (CPU_src1_value_a3 >= CPU_src2_value_a3) :
                     CPU_is_blt_a3  ? (CPU_src1_value_a3 < CPU_src2_value_a3) ^ (CPU_src1_value_a3[31] != CPU_src2_value_a3[31]) :
                     CPU_is_bge_a3  ? (CPU_src1_value_a3 >= CPU_src2_value_a3) ^ (CPU_src1_value_a3[31] != CPU_src2_value_a3[31]) :
                     1'b0;
         
         // Valid signals to handle flow hazards due to branches and loads
         assign CPU_valid_taken_br_a3 = (CPU_taken_br_a3 && CPU_valid_a3);
         assign CPU_valid_load_a3 = (CPU_is_load_a3 && CPU_valid_a3);
         assign CPU_valid_jump_a3 = (CPU_is_jump_a3 && CPU_valid_a3);
         
         // JALR Target PC
         assign CPU_jalr_tgt_pc_a3[31:0] = CPU_src1_value_a3 + CPU_imm_a3 ;
         
         // Assert valid only if, in the previous two instructions:
         //   - a branch was not taken
         //   - were not load instructions
         //   - were not jump instructions
         assign CPU_valid_a3 = !(CPU_valid_taken_br_a4 || CPU_valid_taken_br_a5 ||
                    CPU_valid_load_a4 || CPU_valid_load_a5 ||
                    CPU_valid_jump_a4 || CPU_valid_jump_a5);
         
         // REGISTER FILE WRITE
         assign CPU_rf_wr_en_a3 = (!CPU_valid_load_a3 && !CPU_valid_load_a4) && (CPU_rd_valid_a3 && (CPU_rd_a3 != 5'b0) && CPU_valid_a3) || CPU_valid_load_a5;
         assign CPU_rf_wr_index_a3[4:0] = CPU_valid_load_a5 ? CPU_rd_a5 : CPU_rd_a3;
         assign CPU_rf_wr_data_a3[31:0] = CPU_valid_load_a5 ? CPU_ld_data_a5 : CPU_result_a3;
         
      //_@4
         // DMEM: Mini 1-R/W Memory
         //       16 entries, 32-bit wide
         assign CPU_dmem_wr_en_a4 = (CPU_is_s_instr_a4 && CPU_valid_a4);
         assign CPU_dmem_rd_en_a4 = CPU_valid_load_a4;
         assign CPU_dmem_addr_a4[3:0] = CPU_result_a4[5:2];
         assign CPU_dmem_wr_data_a4[31:0] = CPU_src2_value_a4;
         
      //_@5
         // Load data from DMEM to RF 2 cycles after valid_load is asserted
         assign CPU_ld_data_a5[31:0] = CPU_dmem_rd_data_a5;
         
         
      
   
   // Assert these to end simulation (before Makerchip cycle limit).
   //*passed = *cyc_cnt > 40;
   //*passed = |cpu/xreg[15]>>5$value == (1+2+3+4+5+6+7+8+9);
   //*failed = 1'b0;
   
   /*SV_plus*/
      always @ (posedge clk)
      begin
         out = CPU_Xreg_value_a5[15];
      end
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   //_|cpu
      //_\source /raw.githubusercontent.com/arunkpv/vsdhdp/main/code/riscv/verilog/include/riscvshelllib.tlv 20   // Instantiated from top.tlv, 321 as: m4+imem(@1)
         // Instruction Memory containing program defined by m4_asm(...) instantiations.
         //_@1
            /*SV_plus*/
               // The program in an instruction memory.
               (* keep *) wire [31:0] instrs [0:12-1];
               assign instrs[0] = {7'b0000000, 5'd0, 5'd0, 3'b000, 5'd10, 7'b0110011};
               assign instrs[1] = {7'b0000000, 5'd0, 5'd0, 3'b000, 5'd15, 7'b0110011};
               assign instrs[2] = {7'b0000000, 5'd0, 5'd0, 3'b000, 5'd14, 7'b0110011};
               assign instrs[3] = {12'b1010, 5'd0, 3'b000, 5'd12, 7'b0010011};
               assign instrs[4] = {7'b0000000, 5'd0, 5'd0, 3'b000, 5'd13, 7'b0110011};
               assign instrs[5] = {7'b0000000, 5'd14, 5'd13, 3'b000, 5'd14, 7'b0110011};
               assign instrs[6] = {12'b1, 5'd13, 3'b000, 5'd13, 7'b0010011};
               assign instrs[7] = {1'b1, 6'b111111, 5'd12, 5'd13, 3'b100, 4'b1100, 1'b1, 7'b1100011};
               assign instrs[8] = {7'b0000000, 5'd0, 5'd14, 3'b000, 5'd10, 7'b0110011};
               assign instrs[9] = {7'b0000000, 5'd10, 5'd0, 3'b010, 5'b00100, 7'b0100011};
               assign instrs[10] = {12'b00100, 5'd0, 3'b010, 5'd15, 7'b0000011};
               assign instrs[11] = {1'b1, 10'b1111101010, 1'b1, 8'b11111111, 5'd7, 7'b1101111};
            
            generate for (imem = 0; imem <= 11; imem=imem+1) begin : L1_CPU_Imem //_/imem
               assign CPU_Imem_instr_a1[imem][31:0] = instrs[imem];
            end endgenerate
            //_?$imem_rd_en
               assign CPU_imem_rd_data_a1[31:0] = CPU_Imem_instr_a1[CPU_imem_rd_addr_a1];
            
            
            
               
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
                              
              
          
      //_\end_source    // Args: (read stage)
      //_\source /raw.githubusercontent.com/arunkpv/vsdhdp/main/code/riscv/verilog/include/riscvshelllib.tlv 73   // Instantiated from top.tlv, 322 as: m4+rf(@2, @3)
         // Reg File
         //_@3
            generate for (xreg = 0; xreg <= 31; xreg=xreg+1) begin : L1_CPU_Xreg //_/xreg

               // For $wr.
               wire L1_wr_a3;

               assign L1_wr_a3 = CPU_rf_wr_en_a3 && (CPU_rf_wr_index_a3 != 5'b0) && (CPU_rf_wr_index_a3 == xreg);
               assign CPU_Xreg_value_a3[xreg][31:0] = CPU_reset_a3 ?   xreg           :
                              L1_wr_a3        ?   CPU_rf_wr_data_a3 :
                                             CPU_Xreg_value_a4[xreg][31:0];
            end endgenerate
         //_@2
            //_?$rf_rd_en1
               assign CPU_rf_rd_data1_a2[31:0] = CPU_Xreg_value_a4[CPU_rf_rd_index1_a2];
            //_?$rf_rd_en2
               assign CPU_rf_rd_data2_a2[31:0] = CPU_Xreg_value_a4[CPU_rf_rd_index2_a2];
            `BOGUS_USE(CPU_rf_rd_data1_a2 CPU_rf_rd_data2_a2) 
      //_\end_source  // Args: (read stage, write stage) - if equal, no register bypass is required
      //_\source /raw.githubusercontent.com/arunkpv/vsdhdp/main/code/riscv/verilog/include/riscvshelllib.tlv 90   // Instantiated from top.tlv, 323 as: m4+dmem(@4)
         // Data Memory
         //_@4
            generate for (dmem = 0; dmem <= 15; dmem=dmem+1) begin : L1_CPU_Dmem //_/dmem

               // For $wr.
               wire L1_wr_a4;

               assign L1_wr_a4 = CPU_dmem_wr_en_a4 && (CPU_dmem_addr_a4 == dmem);
               assign CPU_Dmem_value_a4[dmem][31:0] = CPU_reset_a4 ?   dmem :
                              L1_wr_a4        ?   CPU_dmem_wr_data_a4 :
                                             CPU_Dmem_value_a5[dmem][31:0];
            end endgenerate
                                        
            //_?$dmem_rd_en
               assign CPU_dmem_rd_data_a4[31:0] = CPU_Dmem_value_a5[CPU_dmem_addr_a4];
            `BOGUS_USE(CPU_dmem_rd_data_a4)
      //_\end_source    // Args: (read/write stage)
   
   //m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
/*   
   |cpu
      @2
         \viz_js
            render() {
               //let is_s_instr    = "$is_s_instr:    "+'$is_s_instr'.asInt(NaN).toString()+"\n";
               
               let imm           = "$imm            : "+'$imm'.asInt(NaN).toString()+" (0x"+'$imm'.asInt(NaN).toString(16)+")"+"\n";
               
               let rf_rd_index1  = "$rf_rd_index1   : "+'$rf_rd_index1'.asInt(NaN).toString()+" (0x"+'$rf_rd_index1'.asInt(NaN).toString(16)+")"+"\n";
               let rf_rd_index2  = "$rf_rd_index2   : "+'$rf_rd_index2'.asInt(NaN).toString()+" (0x"+'$rf_rd_index2'.asInt(NaN).toString(16)+")"+"\n";
               
               let valid_load_3  = ">>3$valid_load  : "+'>>3$valid_load'.asInt(NaN).toString()+"\n";
               let rf_wr_index_3 = ">>3$rf_wr_index : "+'>>3$rf_wr_index'.asInt(NaN).toString()+" (0x"+'>>3$rf_wr_index'.asInt(NaN).toString(16)+")"+"\n";
                
               let valid_load_2  = ">>2$valid_load  : "+'>>2$valid_load'.asInt(NaN).toString()+"\n";
               let rf_wr_index_2 = ">>2$rf_wr_index : "+'>>2$rf_wr_index'.asInt(NaN).toString()+" (0x"+'>>2$rf_wr_index'.asInt(NaN).toString(16)+")"+"\n";
               
               let rf_wr_index_1 = ">>1$rf_wr_index : "+'>>1$rf_wr_index'.asInt(NaN).toString()+" (0x"+'>>1$rf_wr_index'.asInt(NaN).toString(16)+")"+"\n";
               let rd_valid      = "$rd_valid       : "+'$rd_valid'.asInt(NaN).toString()+"\n";
               let rf_wr_en      = ">>1$rf_wr_en       : "+'>>1$rf_wr_en'.asInt(NaN).toString()+"\n";
               let ld_data_3     = ">>3$ld_data     : "+'>>3$ld_data'.asInt(NaN).toString()+" (0x"+'>>3$ld_data'.asInt(NaN).toString(16)+")"+"\n";
               let result_2      = ">>2$result      : "+'>>2$result'.asInt(NaN).toString()+" (0x"+'>>2$result'.asInt(NaN).toString(16)+")"+"\n";
               let result_1      = ">>1$result      : "+'>>1$result'.asInt(NaN).toString()+" (0x"+'>>1$result'.asInt(NaN).toString(16)+")"+"\n";
               let rf_rd_data1   = "$rf_rd_data1    : "+'$rf_rd_data1'.asInt(NaN).toString()+" (0x"+'$rf_rd_data1'.asInt(NaN).toString(16)+")"+"\n";
               let rf_rd_data2   = "$rf_rd_data2    : "+'$rf_rd_data2'.asInt(NaN).toString()+" (0x"+'$rf_rd_data2'.asInt(NaN).toString(16)+")"+"\n";
               
               let src1_val      = "$src1_val       : "+'$src1_value'.asInt(NaN).toString()+" (0x"+'$src1_value'.asInt(NaN).toString(16)+")"+"\n";
               let src2_val      = "$src2_val       : "+'$src2_value'.asInt(NaN).toString()+" (0x"+'$src2_value'.asInt(NaN).toString(16)+")"+"\n";
               
               let str_2 = "@2:------------------------\n"
                         //+ is_s_instr
                         + imm
                         + rf_rd_index1 + rf_rd_index2 + "\n"
                         + valid_load_3 + rf_wr_index_3 + "\n"
                         + valid_load_2 + rf_wr_index_2 + "\n"
                         + rf_wr_index_1 + rd_valid + rf_wr_en + "\n"
                         + ld_data_3
                         + result_2
                         + result_1
                         + rf_rd_data1 + rf_rd_data2+ "\n"
                         + src1_val + src2_val;
               
               let str_stage2 = new fabric.Text(str_2, {
                  top: 0, left: 0,
                  fontSize: 14, fontFamily: "monospace"
               });
               return [str_stage2];
            },
            where: {left: 100, top: 180}

   |cpu
      @3
         \viz_js
            render() {
               let alu_result    = "$result         : "+'$result'.asInt(NaN).toString()+" (0x"+'$result'.asInt(NaN).toString(16)+")"+"\n";
               
               let src1_val      = "$src1_val       : "+'$src1_value'.asInt(NaN).toString()+" (0x"+'$src1_value'.asInt(NaN).toString(16)+")"+"\n";
               let src2_val      = "$src2_val       : "+'$src2_value'.asInt(NaN).toString()+" (0x"+'$src2_value'.asInt(NaN).toString(16)+")"+"\n";
               
               let imm           = "$imm            : "+'$imm'.asInt(NaN).toString()+" (0x"+'$imm'.asInt(NaN).toString(16)+")"+"\n";
               
               let rd_valid      = "$rd_valid       : "+'$rd_valid'.asInt(NaN).toString()+"\n";
               let rf_wr_en      = "$rf_wr_en       : "+'$rf_wr_en'.asInt(NaN).toString()+"\n";
               
               let str_3 = "@3:------------------------\n"
                         + src1_val + src2_val
                         + imm
                         + alu_result +"\n"
                         + rd_valid + rf_wr_en;
               
               let str_stage3 = new fabric.Text(str_3, {
                  top: 0, left: 0,
                  fontSize: 14, fontFamily: "monospace"
               });
               return [str_stage3];
            },
            where: {left: 100, top: 620}
*/
// Somehow, uncommenting this section makes the viz_js for @3 to go away
/*
   |cpu
      @4
         \viz_js
            render() {
               let rf_wr_en      = "$rf_wr_en      : "+'$rf_wr_en'.asInt(NaN).toString()+"\n";
               let valid_load_2  = ">>2$valid_load : "+'>>2$valid_load'.asInt(NaN).toString()+"\n";
               let rd_2          = ">>2$rd         : "+'>>2$rd'.asInt(NaN).toString()+" (0x"+'>>2$rd'.asInt(NaN).toString(16)+")"+"\n";
               let rd            = "$rd            : "+'$rd'.asInt(NaN).toString()+" (0x"+'$rd'.asInt(NaN).toString(16)+")"+"\n";
               let rf_wr_index   = "$rf_wr_index   : "+'$rf_wr_index'.asInt(NaN).toString()+" (0x"+'$rf_wr_data'.asInt(NaN).toString(16)+")"+"\n";
               
               let ld_data_2     = ">>2$ld_data    : "+'>>2$ld_data'.asInt(NaN).toString()+" (0x"+'>>2$ld_data'.asInt(NaN).toString(16)+")"+"\n";
               let result        = "$result        : "+'$result'.asInt(NaN).toString()+" (0x"+'$result'.asInt(NaN).toString(16)+")"+"\n";
               
               let rf_wr_data    = "$rf_wr_data    : "+'$rf_wr_data'.asInt(NaN).toString()+" (0x"+'$rf_wr_data'.asInt(NaN).toString(16)+")"+"\n";
               
               let str_4 = "@4:------------------------\n"
                         + rf_wr_en
                         + valid_load_2 + "\n"
                         + rd_2 + rd + "\n"
                         + rf_wr_index + "\n"
                         + ld_data_2
                         + result + "\n"
                         + rf_wr_data;
               
               let str_stage4 = new fabric.Text(str_4, {
                  top: 0, left: 0,
                  fontSize: 14, fontFamily: "monospace"
               });
               return [str_stage4];
            },
            where: {left: 400, top: 590}
*/
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.
//_\SV
   endmodule


// Undefine macros defined by SandPiper.
`undef BOGUS_USE
