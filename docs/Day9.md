[Back to TOC](../README.md)  
[Prev: Day8](Day8.md)$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$[Next: Day 10](Day_10.md)  
_________________________________________________________________________________________________________  
# Day 9
## Complete Pipelined RISC-V CPU Microarchitecture
Our RISC-V core from the previous day is still incomplete w.r.t the instructions implemented, and additionally we need to do pipelining and handling of the pipeline hazards.  
We need to do the following to complete the CPU Design:
  1) Pipeline the CPU, taking care of the data dependency & control flow hazards
  2) Complete the implementation of the remaining ALU instructions
  3) Implement DMEM & Load, Store instructions
  4) Implement the Unconditional Jump (JAL, JALR) instructions

|**Pipelining the RISC-V CPU Core ![D9_RISCV_Pipelined](/docs/images/D9_RISCV_Pipelined.png)|
|-|
<br>

### Pipelining the CPU: Using 3-Cycle $valid signal
First, we will implement with a simplified 3-stage pipeline with using a 3-Cycle valid signal, the various stages being:  
  * PC
  * Instruction Fetch + Decode
  * RF Read, ALU
  * RF Write, Branch Instrn. logic
<br>

This implementation would have an IPC of only ~1/3 as the valid signal is active once every 3 cycles (HLLHLL...) indicating only one valid instruction in the pipe at any point. We do this step to partition the core (or logic) into the respective pipeline stages first without having to worry about handling the pipeline hazards.   

|**Waterfall Logic Diagram with 3-Cycle Valid**<br>  ![D9_Pipelining_with_3Cycle_Valid](/docs/images/D9_Pipelining_with_3Cycle_Valid.png)|
|-|
|**TL-V Logic Implementation Diagram**<br>  ![D9_3Cycle_Valid_Diagram](/docs/images/D9_3Cycle_Valid_Diagram.png)|

|**Makerchip-generated Block Diagram for 3-Cycle Valid design**<br>  ![D9_3Cycle_Valid_Makerchip](/docs/images/D9_3Cycle_Valid_Makerchip.png)|
|-|
<br>

### Pipelining the CPU: Solving the data & control hazards
#### 1) Data Hazard: Read-After-Write (RAW) in the Refister File
  * There is a 2-cycle delay (by design) between RF Read and Write operations.
  * Hence we have a Read-After-Write (RAW) data hazard if the current instruction in the pipe is trying to read from the Register File (RF) when the previous instruction had written to the same RF index.
  * To solve this, we need to add a Register File Bypass Mux at the input of the ALU and select the previous ALU output if the previous instruction was writing to the RF index accessed in the current instruction.

  |**Register File Bypass Waterfall Logic Diagram**<br>  ![D9_RF_Bypass_Logic_Diagram](/docs/images/D9_RF_Bypass_Logic_Diagram.png)|
  |-|
  |**Register File Bypass TL-V Implementation**<br>  ![D9_RF_Bypass_TLV_Diagram](/docs/images/D9_RF_Bypass_TLV_Diagram.png)|

####  2) Control Hazard: Branch Instructions
  * We have control flow hazards when a branch is taken.
  * The PC logic is updated to handle the case when a branch is taken or not.
  
  |**Branch Instruction Control Hazard**<br>  ![D9_Branch_Hazard](/docs/images/D9_Branch_Hazard.png)|
  |-|

### Complete the ALU
The Instruction Decoder is updated to decode all the instructions and the complete ALU is implemented.
Note: All load instructions are treated as the same as the LW instruction. 

### DMEM & Load, Store Instructions
The DMEM is a single-port R/W memory with 16 entries, 32-bit wide.  
The DMEM is placed in the 4th pipeline stage.  
|**DMEM**<br>  ![D9_DMEM](/docs/images/D9_DMEM.png)|
|-|

**LOAD (LW, LH, LB, LHU, LBU) Instructions**  
LOAD rd, imm(rs1)  
Loads the data from the DMEM address given by (rs1 + imm) to destination register provided by rd.  
i.e., rd <= DMEM(rs1 + imm)  
<br>

**STORE (SW, SH, LB) Instructions**  
STORE rs2, imm(rs1)  
Stores the data from rs2 to the DMEM address given by (rs1 + imm).  
i.e., rd <= DMEM(rs1 + imm)  
<br>

The $dmem_addr[3:0] is generated by the ALU by treating the load and store instructions to be equivalent to the ADDI instruction.  
```
i.e., The ALU performs the following:
LOAD/ STORE : ($is_load || $is_s_instr) ? ($src1_value + $imm) 
ADDI        :                 $is_addi  ? ($src1_value + $imm) :

Since the DMEM is 32-bit wide and not byte or half-addressable:
$dmem_addr[3:0] = $result[5:2];
```

Muxes need to be placed at the inputs of RF write index ($rf_wr_index) and RF write data ($rf_wr_data) ports to select the appropriate values depending on the validity of the load instruction.  
|**DMEM Load/ Store**<br>  ![D9_LoadStore_TLV_Logic_Diagram2](/docs/images/D9_LoadStore_TLV_Logic_Diagram2.png)|
|-|

Additionally, the Program Counter logic has to be updated for load redirects.

### Unconditional Jump (JAL, JALR) Instructions
  * JAL : Jump to (PC + IMM), equivalent to an unconditional branch w.r.t the calculation of the target address.
  * JALR: Jump to (SRC1 + IMM)

The logic to calculate the branch target for JALR needs to be implemented.  
The Program Counter logic also needs to be modified to handle the jumps.  

### Complete Pipelined RISC-V CPU Core Implementation in Makerchip
<!--[**Link to SVG file of the RISC-V Core Block Diagram**](https://htmlpreview.github.io/?https://raw.githubusercontent.com/arunkpv/vsd-hdp/main/docs/html/riscv.html)  -->
Click on the image below to open up the interactive svg file:  
[![D9_Complete_Pipelined_RISCV_Core](/docs/images/D9_Complete_Pipelined_RISCV_Core.png)](https://htmlpreview.github.io/?https://raw.githubusercontent.com/arunkpv/vsd-hdp/main/docs/html/riscv.html)

_________________________________________________________________________________________________________  
[Prev: Day8](Day8.md)$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$[Next: Day 10](Day_10.md)  
